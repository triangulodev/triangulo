---
title: "5 m√©todos do Array no JS que voc√™ deveria usar mais"
description: "A classe Array possue muitos m√©todos que podem facilitar muito a vida de quem trabalha com JavaScript, mas nem todo mundo usa alguns dos seus m√©todos como .some ou .every."
ogImage: "/posts/5-metodos-array/social.png"
date: "2020-11-23"
authorName: "Hugo de Oliveira"
authorImage: "/authors/hugo.png"
---

Alguns dos m√©todos do Array j√° s√£o bastante conhecidos por quem trabalha com JavaScript. Um deles √© o `.map`, que tanto usamos para transformar valores em um Array. Entretanto, existem alguns m√©todos que eu quase nunca vi as pessoas usando, mesmo quando eles seriam perfeitos para o problema que elas estavam tentando resolver.

## `.some`

O m√©todo `.some` serve para voc√™ verificar se uma condi√ß√£o √© verdadeira para pelo menos um valor dentro do Array ‚Äì um caso de uso bastante comum. O `.some` recebe uma fun√ß√£o `callbackFn` que deve testar cada um dos elementos do Array. A `callbackFn` recebe tr√™s argumentos:

- `element`: o valor do elemento;
- `index`: o √≠ndice deste elemento no Array;
- `array`: o Array sendo testado.

O valor retornado pela `callbackFn` deve ser _convert√≠vel_ para `true` ou `false` atrav√©s da [coer√ß√£o de tipos](https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion).

Para mostrar um exemplo de como usar o m√©todo `.some`, criaremos um Array `fruits` e as fun√ß√µes `isApple` e `isKiwi` que testar√£o se um elemento √© uma ma√ß√£ ou um kiwi.

```js
let fruits = [üçé, üçè, üçå, üçä, ü••];

function isApple(fruit) {
  return fruit === üçé;
}

function isKiwi(fruit) {
  return fruit === ü•ù;
}
```

Podemos ent√£o usar o m√©todo `.some` no Array `fruits`, passando como `callbackFn` uma das duas fun√ß√µes que criamos. Esta chamada retornar√° `true` se as fun√ß√µes retornarem `true` para pelo menos um dos elementos em `fruits`.

```js
fruits.some(isApple); // => true
fruits.some(isKiwi); // => false
```

## `.every`

Parecido com o `.some`, o `.every` √© usado para verificar se uma condi√ß√£o √© verdadeira para todos os elementos de um Array. Esse m√©todo tamb√©m recebe uma fun√ß√£o `callbackFn`, com os mesmo argumentos `element`, `index` e `array`.

No exemplo a seguir, criaremos um Array de objetos com dados sobre pessoas e os testaremos com fun√ß√µes que verificam se os dados delas atendem √† uma condi√ß√£o.

```js
let people = [
  { name: "Jo√£o", age: 20 },
  { name: "Maria", age: 18 },
  { name: "Lucas", age: 22 },
];

function isOverAge(person) {
  return person.age >= 18;
}

function isMaria(person) {
  return person.name === "Maria";
}
```

A fun√ß√£o `isOverAge` testar√° se `person.age` √© maior do que `18`. Como esta condi√ß√£o √© verdadeira para todos os elementos do Array, o m√©todo `.every` retornar√° `true` com essa condi√ß√£o.

```js
people.every(isOverAge); // => true
```

J√° a fun√ß√£o `isMaria` testar√° se `person.name` √© `'Maria'`, o que n√£o √© verdadeiro para todos os elementos do Array `people`. A chamada do m√©todo `.every`, neste caso, retornar√° `false`.

```js
people.every(isMaria); // => false
```

## `.flat`

Algumas vezes temos um Array que tem outros Arrays dentro dele e precisamos transformar todos esses elementos em um grande Array com apenas um n√≠vel de profundidade. O m√©todo `.flat` faz exatamente isso. Ele recebe um √∫nico argumento opcional `depth`, que pode ser utilizado para configurar o n√≠vel de profundidade de sub-Arrays que devem ser concatenados em um √∫nico n√≠vel.

```js
let arrays = [1, 2, 3, [4, 5], [6, 7, [8, 9]]];

arrays.flat(); // => [1, 2, 3, 4, 5, 6, 7, [8, 9]]
arrays.flat(2); // => [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Como por padr√£o `depth` √© igual a `1`, a primeira chamada ainda retorna um array com um sub-array. Em casos em que voc√™ n√£o tem ideia do n√≠vel de profundidade dos sub-arrays mas quer ter certeza que todos os elementos estar√£o em apenas um √∫nico n√≠vel, voc√™ pode passar `Infinity` como argumento para o m√©todo `.flat()`.

```js
let arrays = [[[[[[[[[[[1, 2, 3]], [[[[[[4]]]]]]]]]]]]]]];

arrays.flat(Infinity); // => [1, 2, 3, 4]
```

## `.flatMap`

Um dos casos de uso mais comuns para o m√©todo `.flat` √© utiliz√°-lo logo ap√≥s uma chamada ao `.map` que gerou sub-arrays. Podemos utilizar como exemplo exemplo listar todos os amigos (`.friends`) de todas as pessoas (`person`) em um Array.

```js
let people = [
  { name: "Jo√£o", friends: [{ name: "Gabriel" }, { name: "Laura" }] },
  { name: "Maria", friends: [{ name: "Bruna" }, { name: "Luiza" }] },
  { name: "Rebeca", friends: [{ name: "Gustavo" }] },
];
```

Se usarmos apenas o m√©todo `.map` com uma fun√ß√£o para retornar todos os amigos de cada uma das pessoas, ter√≠amos um Array com sub-arrays.

```js
function getFriends(person) {
  return person.friends;
}

people.map(getFriends);
/* =>
[
  [{name: 'Gabriel'}, {name: 'Laura'}}],
  [{name: 'Bruna'}, {name: 'Luiza}],
  [{name: 'Gustavo}]
]
*/
```

J√° com o m√©todo `.flatMap`, este Array retornado pela fun√ß√£o `getFriends` ser√° concatenado com os resultados anteriores, retornando um Array com apenas um n√≠vel de profundidade.

```js
people.flatMap(getFriends);
/* =>
[
  {name: 'Gabriel'},
  {name: 'Laura'}},
  {name: 'Bruna'},
  {name: 'Luiza},
  {name: 'Gustavo}
]
*/
```

Vale alertar que, ao contr√°rio do m√©todo `.flat`, n√£o √© poss√≠vel controlar a profundidade de sub-arrays que ser√£o concatenados em apenas um n√≠vel. O m√©todo `.flatMap` concatenar√° elementos em apenas um n√≠vel de profundidade.

## `.concat`

Eu sinceramente n√£o sei porqu√™ poucas pessoas utilizam o `.concat`, mas se precisasse apostar seria por causa da grande quantidade de exemplos que vemos utilizando o operador de `spread` (`...`) para juntar elementos de diferentes Arrays em um s√≥.

O m√©todo `.concat` pode ser utilizado para concatenar diferentes itens em um √∫nico Array. Ele recebe como argumento um ou mais itens que podem tanto ser valores quanto outros Arrays e retorna um novo Array com todos esses itens concatenados.

```js
[1].concat(2); //         => [1, 2]
[1].concat(2, 3); //      => [1, 2, 3]
[1].concat([2, 3]); //    => [1, 2, 3]
[1].concat(2, [3, 4]); // => [1, 2, 3, 4]
```

Sempre que voc√™ precisar verificar se um valor √© ou n√£o um Array antes de utilizar um operador `spread`, considere usar o m√©todo `.concat`.

```js
let item = 3;
[1, 2, ...(Array.isArray(item) ? item : [item])]; // ‚ùå
[1, 2].concat(item); // ‚úÖ
```

Como o m√©todo `.concat` funciona tanto em valores como em Arrays, tamb√©m podemos implementar uma fun√ß√£o que se comporta como o m√©todo `.flat` facilmente:

```js
function flat(array, nestedArray) {
  return array.concat(...nestedArray);
}

flat([1, 2], [3, [4, 5]]); // => [1, 2, 3, 4, 5]
```

No exemplo acima, utilizamos o operador `spread` para usar cada um dos elementos de `nestedArray` como argumentos para a chamada do m√©todo `.concat`.

## Continue aprendendo

A classe Array tem muitos m√©todos √∫teis para facilitar a sua vida no JavaScript enquanto estiver trabalhando com Arrays. Quando utilizamos m√©todos como `.some` e `.every`, mostramos muito mais a inten√ß√£o de um c√≥digo do que quando os implementamos com loops `for` ou outros m√©todos mais gen√©ricos como o `.reduce`. Para aprender mais sobre outros m√©todos dispon√≠veis na classe Array, n√£o deixe de visitar a [refer√™ncia completa no MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) ou a pr√≥pria [especifica√ß√£o oficial da classe Array](https://tc39.es/ecma262/#sec-properties-of-the-array-prototype-object).

Se voc√™ transforma muitos Arrays no seu c√≥digo JavaScript e j√° acha que os m√©todos da classe Array nem sempre s√£o suficientes, vale a pena usar bibliotecas como o [Lodash](https://lodash.com/).
